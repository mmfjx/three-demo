<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - lights - point lights</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <script src="//s3plus.meituan.net/v1/mss_814dc1610cda4b2e8febd6ea2c809db5/distribute/79960b81-79bd-4d50-9c50-2a6ae5b9926c_1540204574498?filename=three%400.97.0.min.js"></script>

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/98/three.js"></script> -->
        <script src="./OrbitControls.js"></script>
        <script src="./tween.js"></script>
        <script>
            var camera, scene, renderer,controls, clock,
            maxParticles, text,fly,
            sphere, sphereGeometry, particles;


            init();
            animate();

            function init() {

                camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.z = 200;
                scene = new THREE.Scene();

                var light = new THREE.AmbientLight( 0xffffff ); // soft white light
                scene.add( light );

                scene.add( new THREE.AxesHelper( 100 ) );

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );
                controls = new THREE.OrbitControls( camera, renderer.domElement );
                drawPoints();
                // drawText();

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function drawPoints() {
                maxParticles = 60;
                let radius = 60;
                let particlesDelay = 1;
                let positions = [];
                let spherical = new THREE.Spherical();
                spherical.radius = radius;
                let vec3 = new THREE.Vector3();
                for (let i = 0; i < maxParticles; i++) {
                    for (let j = 0; j < maxParticles; j++) {
                        let u = Math.random();
                        let v = Math.random();
                        // let u = i / maxParticles;
                        // let v = j / maxParticles;
                        spherical.theta = u * Math.PI * 2 - Math.PI / 2;
                        spherical.phi = v * Math.PI;
                        vec3.setFromSpherical(spherical);
                        positions.push(vec3.x);
                        positions.push(vec3.y);
                        positions.push(vec3.z);

                    }
                }
                let positions3 = new Float32Array(positions.length);
                // positions3 = positions3.reverse();
                for (let j = 0; j < positions.length; j++) {
                    positions3[j] = positions[j];
                }

                let sphereGeometry = new THREE.BufferGeometry();
                sphereGeometry.addAttribute('position', new THREE.BufferAttribute(positions3, 3));
                sphereGeometry.computeBoundingSphere();
                sphereGeometry.dynamic = true;


                var material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.5,
                });
                sphere = new THREE.Points(sphereGeometry, material);
                scene.add(sphere);
                setTimeout(() => {
                    fly = true;
                    clock = new THREE.Clock();
                }, 1000)
            }
            function update() {
                let position = sphere.geometry.attributes.position;
                let delta = clock.getDelta() * 10;
                let speed = 20;
                // 分奇偶
                for(let i = 0;i < sphere.geometry.attributes.position.count;i++) {
                    let px = position.getX(i);
                    let py = position.getY(i);
                    let pz = position.getZ(i);
                    let x;
                    let toX;
                    if (i % 2 == 1) {
                        if (px > 0) {
                        toX = THREE.Math.randInt(px, px + 10);
                        x = px + toX / (px + toX) * speed * delta;
                        } else {
                            toX = THREE.Math.randInt(px, px - 10);
                            x = px - toX / (px + toX) * speed * delta;
                        }
                        sphere.geometry.attributes.position.setX(i, x);
                        sphere.geometry.attributes.position.needsUpdate = true;
                    }
                       
                }
                setTimeout(() => {
                    for(let i = 0;i < sphere.geometry.attributes.position.count;i++) {
                        let px = position.getX(i);
                        let py = position.getY(i);
                        let pz = position.getZ(i);
                        let x;
                        let toX;
                        if (i % 2 === 0) {
                            if (px > 0) {
                            toX = THREE.Math.randInt(px, px + 10);
                            x = px + toX / (px + toX) * speed * delta;
                            } else {
                                toX = THREE.Math.randInt(px, px - 10);
                                x = px - toX / (px + toX) * speed * delta;
                            }
                            sphere.geometry.attributes.position.setX(i, x);
                            sphere.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                }, 300)
                

            }

            function drawText() {
                var loader = new THREE.FontLoader();

                loader.load( 'https://dl.dropboxusercontent.com/s/bkqic142ik0zjed/swiss_black_cond.json?', function ( font ) {

                var textGeo = new THREE.TextGeometry( 'TR', {
                    font: font,
                    size: 40,
                    height: 5,
                    curveSegments: 10,
                    bevelEnabled: true,
                    bevelThickness: 2,
                    bevelSize: 8,
                    bevelSegments: 10
                } );
                var material = new THREE.PointsMaterial({
                    color: 0x00ffff,
                    size: 0.5,
                    // transparent: true,
                    // blending: THREE.AdditiveBlending,
                    // depthWrite: false
                });
                var material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

				// textGeo.computeBoundingBox();
				// textGeo.computeVertexNormals();
                // text = new THREE.Points(textGeo, material);
                text = new THREE.Mesh(textGeo, material);
                scene.add(text);
            });
        }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                requestAnimationFrame( animate );
                render();
                TWEEN.update();
                if (fly) {
                    update();
                }
            }

            function render() {
                renderer.render( scene, camera );
                controls.update();
                // update();

            }

        </script>
    </body>
</html>