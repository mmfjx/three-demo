<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - lights - point lights</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <script src="//s3plus.meituan.net/v1/mss_814dc1610cda4b2e8febd6ea2c809db5/distribute/79960b81-79bd-4d50-9c50-2a6ae5b9926c_1540204574498?filename=three%400.97.0.min.js"></script>

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/98/three.js"></script> -->
        <script src="./OrbitControls.js"></script>
        <script src="./tween.js"></script>
        <script>
            var camera, scene, renderer,controls,
            maxParticles, text,
            sphere, sphereGeometry, particles;

            var clock = new THREE.Clock();

            init();
            animate();

            function init() {

                camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.z = 200;
                scene = new THREE.Scene();

                var light = new THREE.AmbientLight( 0xffffff ); // soft white light
                scene.add( light );

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );
                controls = new THREE.OrbitControls( camera, renderer.domElement );
                drawPoints();
                // drawText();

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function drawPoints() {
                maxParticles = 60;
                let radius = 60;
                let particlesDelay = 1;
                let positions = [];
                let spherical = new THREE.Spherical();
                spherical.radius = radius;
                let vec3 = new THREE.Vector3();
                for (let i = 0; i < maxParticles; i++) {
                    for (let j = 0; j < maxParticles; j++) {
                        let u = Math.random();
                        let v = Math.random();
                        // let u = i / maxParticles;
                        // let v = j / maxParticles;
                        spherical.theta = u * Math.PI * 2 - Math.PI / 2;
                        spherical.phi = v * Math.PI;
                        vec3.setFromSpherical(spherical);
                        positions.push(vec3.x);
                        positions.push(vec3.y);
                        positions.push(vec3.z);

                    }
                }
                let positions3 = new Float32Array(positions.length);
                // positions3 = positions3.reverse();
                for (let j = 0; j < positions.length; j++) {
                    positions3[j] = positions[j];
                }

                let sphereGeometry = new THREE.BufferGeometry();
                sphereGeometry.addAttribute('position', new THREE.BufferAttribute(positions3, 3));
                sphereGeometry.computeBoundingSphere();
                sphereGeometry.dynamic = true;


                var material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.5,
                });
                sphere = new THREE.Points(sphereGeometry, material);
                scene.add(sphere);
                for(let count = 0;count < positions3.length / 3;count++) {
                    let position = sphere.geometry.attributes.position;
                    // console.log(position.getY(count));
                    if (position.getY(count).toFixed(0) === -60) {
                        return;
                    }
                    let fly = {
                        y: position.getY(count)
                    };
                    new TWEEN.Tween(fly)
                        .to({y: -60}, 2000)
                        .onUpdate((fly) => {
                            sphere.geometry.attributes.position.setY(count, fly.y);
                            sphere.geometry.attributes.position.needsUpdate = true;
                        })
                        .start();
                }

            }

            function drawText() {
                var loader = new THREE.FontLoader();

                loader.load( 'https://dl.dropboxusercontent.com/s/bkqic142ik0zjed/swiss_black_cond.json?', function ( font ) {

                var textGeo = new THREE.TextGeometry( 'TR', {
                    font: font,
                    size: 40,
                    height: 5,
                    curveSegments: 10,
                    bevelEnabled: true,
                    bevelThickness: 2,
                    bevelSize: 8,
                    bevelSegments: 10
                } );
                var material = new THREE.PointsMaterial({
                    color: 0x00ffff,
                    size: 0.5,
                    // transparent: true,
                    // blending: THREE.AdditiveBlending,
                    // depthWrite: false
                });
                var material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

				// textGeo.computeBoundingBox();
				// textGeo.computeVertexNormals();
                // text = new THREE.Points(textGeo, material);
                text = new THREE.Mesh(textGeo, material);
                scene.add(text);
            });
        }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                requestAnimationFrame( animate );
                render();
                TWEEN.update();
            }

            function render() {
                renderer.render( scene, camera );
                controls.update();
                // update();

            }

        </script>
    </body>
</html>